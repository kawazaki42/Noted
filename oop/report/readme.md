Работа с командной строкой
===

Командную строку можно открыть множеством способов.

Например, внутри VS Code.

Для этого есть сочетание клавиш <code>Ctrl+`</code>.

![alt text](vscode-terminal.png)

После этого рекомендуется выполнить команду `chcp 65001`, чтобы установить
UTF-8 как кодировку консоли.

Основные команды консоли:
- `pwd` - отобразить рабочий каталог (_"открытая папка"_)
- `cd <имя>` - сменить рабочий каталог (_"открыть папку"_)
- `ls` - отобразить содержимое текущего каталога (_открытой папки_)
- `mkdir <имя>` - создать каталок (_папку_)

### Редактирование командной строки

Можно перемещаться по истории команд при помощи клавиш
__вверх__ и __вниз__

В зависимости от оболочки и ее настроек,
доступны различные варианты автодополнения при нажатии на `tab`.

Пример `fish`-подобного дополнения на примере `nushell`:

![alt text](working-in-terminal.png)

Компиляция программы на C++ из командной строки
===

Для программирования на C++ необходим компилятор.

На MS Windows можно использовать `g++` (входит в набор `c++`)
в среде MSYS2.

![alt text](gdb-installation.png)

Исполняемый файл компилятора C++ обычно доступен как `c++`.

Чтобы он был доступен без указания полного пути, в MSYS нужно добавить
путь к исполняемым файлам в переменную PATH

На MS Windows это можно сделать так:

![alt text](find-env-cfg.png)

![alt text](envvars.png)

Пример команды компиляции:

```sh
c++ -o main.exe main.cpp calc.cpp -std=c++20
```

- `-o main.exe` - название выходного файла

- `main.cpp` - исходный файл главного модуля

- `calc.cpp` - исходный файл вспомогательного модуля

  (`.h`-файлы в командной строке указывать не надо, они указываются в
   `.cpp`-файле)

- `-std=c++20` - версия стандарта языка

![alt text](build-in-terminal.png)

## Правило трех и пяти

Правила, специфичные для C++.

<!-- Относится к следующим пяти элементам: -->

Гласит, что если в классе есть хотя бы одно из перечисленного,
следует реализовать и остальное:

1. деструктор
2. конструктор копирования
3. оператор присвоения (_перезаписи_) копированием

Начиная со стандарта `C++11`, к этому списку добавляются еще два элемента:

4. конструктор перемещения
5. оператор присвоения перемещением

(относительно) простой пример реализации: 

```c++
template<typename E>
class Array {
    E *ptr;
    size_t size;

  public:

    // конструктор по умолчанию (без параметров).
    //
    // NOTE: приводит к такому же состоянию, что и "опустошение"
    // объекта при перемещении (см. конструктор и operator= для перемещения)
    Array(): ptr(nullptr), size(0) {}

    // 1) Деструктор.
    // без него: будут удалены стековые переменные ptr и size,
    // НО НЕ ДИНАМИЧЕСКАЯ ПАМЯТЬ ДЛЯ МАССИВА
    ~Array() {
        delete[] ptr;

        // не нужно: будет удалена сама
        // size = 0;
    }

    // 2) Конструктор копирования.
    //
    // без него: будет создаваться т.н. поверхностная копия.
    //
    // в this присвоятся size и ptr,
    // но ptr будет общий с other!
    // это будет не копия объекта, а "ссылка" на него
    // (рабочая, но это не то что мы хотим)
    Array(const Array &other) {
        this->size = other.size;
        this->ptr = new E[size];

        for(size_t i{0}; i < size; i++) {
            ptr[i] = other.ptr[i];
        }

        // NOTE: this и other теперь два независимых объекта
    }

    // 3) Оператор присвоения копированием.
    //
    // без него: то же, что и для конструктора копирования,
    // но к тому же еще и утечка памяти (дин. массив по адресу this->ptr)
    Array &operator =(const Array &other) {
        // в случае "самоприсвоения" даже делать ничего не нужно.
        if(this == &other)
            return *this;

        // происходит перезапись, поэтому освобождаем this.

        // кстати, `delete nullptr` это не ошибка;
        // в этом случае ничего не произойдет
        delete[] this->ptr;

        this->size = other.size;
        this->ptr = new E[size];

        for(size_t i{0}; i < size; i++) {
            ptr[i] = other.ptr[i];
        }

        // перегруженные операторы обычно делают так.
        // это для цепных присвоений и для единства с синтаксисом языка.
        return *this;
    }

    // начиная с C++11

    // 4) Конструктор перемещения.
    //
    // без него: пришлось бы лишний раз копировать память из other,
    // несмотря на то что он все равно не нужен.
    Array(Array &&other) {
        // other - либо временный объект,
        // либо явно указанный как условно временный
        // при помощи std::move()

        // "воруем" ресурсы у other, "ему уже все равно" ;)
        ptr = other.ptr;
        size = other.size;

        // Согласно стандарту,
        // теперь other в рабочем, но неуказанном состоянии.

        // в случае с настоящим временным объектом (prvalue),
        // после вызова конструктора перемещения, у пользователя этого класса
        // даже не будет возможности использовать other, т.к. у него даже
        // не было имени.
        // деструктор будет вызван в ближайшее время.

        // в случае с std::move, у пользователя класса остается other.
        // он "рабочий", но "опустошенный".

        // это значит что его можно "восстановить",
        // например вызвав методы инициализации (если такие есть)
        // или присвоив значение, как раз при помощи нашего `operator=`.

        // в обоих случаях, будет вызван деструктор.

        // чтобы он не удалил "украденную" память, укажем,
        // что она больше не принадлежит other,
        // т.е. оставим его в "опустошенном" состоянии
        other.ptr = nullptr;
        other.size = 0;
    }

    // 5) Оператор присвоения перемещением.
    //
    // без него: то же, что и для конструктора перемещения.
    //
    // в случае без конструктора копирования, произошла бы утечка памяти
    // при this->ptr = other.ptr
    Array &operator =(Array &&other) {
        // проверка на "самоприсвоение"
        if(this == &other)
            return *this;

        // перезапись
        delete[] this->ptr;

        ptr = other.ptr;
        size = other.size;

        other.ptr = nullptr;
        other.size = 0;

        return *this;
    }
};
```