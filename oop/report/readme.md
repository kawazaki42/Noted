# Огранизация

## Работа с командной строкой

Командную строку можно открыть множеством способов.

Например, внутри VS Code.

Для этого есть сочетание клавиш <code>Ctrl+`</code>.

![alt text](vscode-terminal.png)

После этого рекомендуется выполнить команду `chcp 65001`, чтобы установить
UTF-8 как кодировку консоли.

Основные команды консоли:
- `pwd` - отобразить рабочий каталог (_"открытая папка"_)
- `cd <имя>` - сменить рабочий каталог (_"открыть папку"_)
- `ls` - отобразить содержимое текущего каталога (_открытой папки_)
- `mkdir <имя>` - создать каталок (_папку_)

### Редактирование командной строки

Можно перемещаться по истории команд при помощи клавиш
__вверх__ и __вниз__

В зависимости от оболочки и ее настроек,
доступны различные варианты автодополнения при нажатии на `tab`.

Пример `fish`-подобного дополнения на примере `nushell`:

![alt text](working-in-terminal.png)

## Компиляция программы на C++ из командной строки

Для программирования на C++ необходим компилятор.

На MS Windows можно использовать `g++` (входит в набор `c++`)
в среде MSYS2.

![alt text](gdb-installation.png)

Исполняемый файл компилятора C++ обычно доступен как `c++`.

Чтобы он был доступен без указания полного пути, в MSYS нужно добавить
путь к исполняемым файлам в переменную PATH

На MS Windows это можно сделать так:

![alt text](find-env-cfg.png)

![alt text](envvars.png)

Пример команды компиляции:

```sh
c++ -o main.exe main.cpp calc.cpp -std=c++20
```

- `-o main.exe` - название выходного файла

- `main.cpp` - исходный файл главного модуля

- `calc.cpp` - исходный файл вспомогательного модуля

  (`.h`-файлы в командной строке указывать не надо, они указываются в
   `.cpp`-файле)

- `-std=c++20` - версия стандарта языка

![alt text](build-in-terminal.png)

## Среда разработки

Visual Studio Code - расширяемый редактор от Microsoft на
основе проекта с открытым исходным кодом,
но с некоторыми проприетарными расширениями.

Для разработки на C++ я использую VSCodium - сборку,
также основанную на этом проекте, но без проприетарных расширений.

<!-- Принцип работы в VSCodium практически не отличается от VS Code,
но некоторые расширения от Microsoft отказываются работать. -->

Помимо расширений, принцип работы в VSCodium
практически не отличается от VS Code.

Сам по себе VS Code дает только самые необходимые
возможности работы с наиболее популярными языками.
Для таких задач, как сборка, отладка, рефакторинг,
используются специальные расширения.

### Сборка, запуск, отладка

В VS Code сборка обычно осуществляется при помощи утилиты `cmake`
и специального расширения CMake Tools.

Для этого необходим файл `CMakeLists.txt`.

Расширение ищет его в корне проекта. Проектом в VS Code обычно является
открытая в нем папка.

После его ручного создания, нужно его заполнить. Расширение позволяет
воспользоваться автодополнением.

![alt text](images/ide/image.png)

В этом файле нужно указать имя исполняемого файла и файлов его исходного кода.

После этого на специальной вкладке можно настроить параметры сборки и запуска.

![alt text](images/ide/image-1.png)

Если все настроено правильно, сборка производится при помощи кнопок
в панели состояния (_статусбаре_)

![alt text](images/ide/image-2.png)

Здесь же можно сразу запустить программу

![alt text](images/ide/image-3.png)

И выполнить отладочный запуск.
Если в файле есть точки останова (_breakpoints_), отладчик остановится на них.

![alt text](images/ide/image-4.png)

Точки останова устанавливаются кликом на красный кружок слева от строки

![alt text](images/ide/image-5.png)

Панель управления отладкой.
Слева направо:
- _продолжить_ выполнение до следующей точки останова
- _шаг в обход_ (не входя внутрь функций в этой строке)
- _шаг со входом_ в функции
- _шаг с выходом_ из текущей функции
- _перезапуск_ отлаживаемой программы
- _остановить отладку_

![alt text](images/ide/image-6.png)

Значения переменных можно просмотреть в нескольких местах:

В коде при наведении

![alt text](images/ide/image-7.png)

На специальной вкладке

![alt text](images/ide/image-8.png)

На той же вкладке, в панели отслеживаемых выражений

![alt text](images/ide/image-9.png)

Стек вызовов можно посмотреть там же, в специальной панели

![alt text](images/ide/image-10.png)

### Файлы

VS Code, в отличие от традиционных, "тяжелых" сред разработки,
не использует файлы для описания проекта.

Обычно проектом является папка.

В некоторых случаях внутри нее может быть создана папка `.vscode`.

В ней хранятся файлы:
- `launch.json` - настройки запуска и отладки проекта
- `tasks.json` - _задачи_, настроенные пользователем
- `settings.json` - локальные настройки проекта
- `c_cpp_properties.json` (для расширения от Microsoft) -
  настройки расширения для C++

Обычно эти файлы исключаются из контроля версий, и вся папка `.vscode`
добавляется в `.gitignore`.

Расширение для CMake использует папку `build` для сборки исходного кода.

Ее тоже следует исключить.

`CMakeLists.txt` содержит настройки системы сборки, поэтому может считаться
частью проекта. Его не следует исключать.

`.clangd` содержит настройки языкового сервера `clangd`.
Он отвечает за статический анализ кода.
Его можно исключить, но можно и оставить.

### Горячие клавиши

- `Ctrl+D` - выделить следующее вхождение строки
- `Ctrl+L` - выделить строку, выделить следующие строки
- `F1`, `Ctrl+Shift+P` - палитра команд
- `Ctrl+Tab` - переключить вкладку
- `Ctrl+/` - закомментировать строку
- <code>Ctrl+`</code> - открыть встроенный терминал
- `Ctrl+J` - переключить нижнюю панель
- `Ctrl+B` - переключить боковую панель
- `Alt+Up`, `Alt+Down` - передвинуть строку вверх/вниз

### Рефакторинг

Вместо официального расширения для C++ здесь используется `clangd`.

`clangd` - языковой сервер для C и C++.
В нем есть интеграция с VSCode (и производными)
при помощи одноименного расширения.

При установке расширение предлагает загрузить и автоматически установить
сам инструмент `clangd`.

Доступные рефакторы для выражения или выделенного фрагмента кода
можно отобразить при помощи команды "Refactor" в контекстном меню
или нажав `Ctrl+Shift+R` или `Ctrl+.`

![alt text](images/ide/image-13.png)

### Параметры компилятора

Обычно задаются в CMakeLists.txt

![alt text](images/ide/image-14.png)

Также есть настройки расширения

![alt text](images/ide/image-15.png)

### TODO

<!-- Создать `TODO`-комментарий можно, написав в нем `TODO`. -->

Комментарии, содержащие строку `TODO` используются для быстрого поиска задач,
которые следует выполнить или завершить.

Для быстрого просмотра `TODO` необходимо расширение, например Todo Tree.

![alt text](images/ide/image-12.png)

![alt text](images/ide/image-11.png)

# Язык C++

## Обработка аргументов командной строки

В C++ функция `main` может иметь или не иметь аргументы:

```c++
int main();
int main(int argc, char *argv[]);
```

где
- `argc` - кол-во параметров командной строки
- `argv` - массив из C-style строк (массивов из символов).
  - каждый элемент - аргумент командной строки

оба эти аргумента считают название программы первым аргументом, т.е.

- если программа вызвана без аргументов как таковых, `argc == 1`
- `argv[0]` - имя программы
  - может быть абсолютным или относительным
    - в зависимости от того, как ее вызвали в оболочке
      (в частности, в терминале)

## Аргументы по умолчанию

Могут быть использованы в конце списка аргументов.

<!-- ```c++
// в *.hpp:
void render(
    std::string input,
    
    std::string outfn = "index.html"
);

// в *.cpp:
// значение параметра не указывается
// иначе происходит ошибка переопределения
void render(std::string input, std::string outfn) {
    // ... implementation ...
}

// использование:
render("about.md", "about.html");  // все параметры указаны явно
render("demo.md");  // outfn станет "index.html"
render();  // 
``` -->

Пример:

```c++
// в *.hpp:
void print(
    const std::vector<std::string> &what,
    const std::string &sep = " ",
    const std::string &end = "\n"
);

// в *.cpp:
// значение параметра не указывается
// иначе происходит ошибка переопределения
void print(
    const std::vector<std::string> &what,
    const std::string &sep,
    const std::string &end
) {
    for(size_t i = 0; i < what.size()-1; i++) {
        std::cout << s;
        std::cout << sep;
    }
    std::cout << s;
    std::cout << end;
}

// использование:
print({"public", "static", "void", "main"});  // обязательный аргумент
// public static void main
print({"2", "2", "2"}, "+");       // sep == "+", end == "\n"
// 2+2+2
print({"2", "2", "2"}, "+", "=\n");  // sep == "+", end == "=\n"
// 2+2+2=
```

## Этапы компиляции

1. Препроцессинг - в основном текстовая работа. Обработка директив:
   - `#include` - буквально копирует текст из
     указанного файла в препроцессируемый
     - обычно аргументы имеют расширение `.h`
   - `#define` - определение т.н. _макроса_, который при нахождении в коде
     будет буквально заменен на заданное содержимое.
   - `#ifndef`/`#endif` - вставка текста
     при условии что указанный макрос определен
     - используется для защиты от многократного включения
2. Компиляция в ассемблерный код
   - компилятор из структурированного кода на C++ (`.cpp`) делает
     низкоуровневый код на языке ассемблера (одно из расширений - `.s`),
     уникальный для каждой архитектуры процессора и
     операционной системы.
3. Сборка в машинный код
   - ассемблер преобразует этот код в машинный (двоичный),
     также зависящий от архитектуры.
   - выходные файлы имеют расширение `.o` (на MSVC: `.obj`)
4. Связывание (компоновка, linking)
   - компоновщик создает исполняемый файл из:
     - `.o`
       - компилированные `.cpp`-файлы
     - `.a`
       - статические библиотеки (архивы из `.o`)
     - `.so` - динамические библиотеки
       - в исполняемый файл сами не попадают, но там появляются ссылки на них
         (зависимости)

## Области памяти

- Регистры
  - ячейки памяти внутри процессора
  - самая быстрая память
  - их количество сравнительно мало
  - в них хранятся локальные переменные, которым хватает регистров
  - остальные попадают в стек
- Стек
  - происходит от слова "стопка"
  - структура данных, которая реализует последовательный доступ в порядке LIFO
    - Last In - First Out
  - используется для локальных переменных
    - это переменные внутри функции
    - называются _статическими_, 
      т.к. количество памяти для них известно на этапе компиляции
    - в т.ч. и объектов
    - память выделяется в начале блока (`{}`)
      - чаще всего это начало исполнения функции
    - очищается в конце блока
      - чаще всего это конец исполнения функции
  - также называется статической памятью
  - операции с памятью часто реализуется при помощи инструкций `PUSH` и `POP`
  - здесь помимо локальных переменных функций хранятся адреса возврата
- Куча
  - не представляет собой упорядоченную структуру
  - дает произвольный доступ к памяти
  - используется для _динамических_ переменных
    - такие переменные обычно используются,
      когда невозможно заранее знать количество необходимой памяти
      - напр. динамические массивы
    - выделяется при помощи оператора `new` или вызова `malloc`
    - освобождается при помощи оператора `delete` или вызова `free`
    - на уровне ассемблера не имеет реализации как таковой
      - работает через системные вызовы
        <!-- - напр. `int 0x80` на x86-32 linux -->
    - также называется динамической памятью
- Секция данных
  - используется для глобалных переменных
    - это переменные, которые объявлены вне функций
  - память выделяется при запуске программы
  - может иметь заранее определенное значение
      - оно тоже присваивается при запуске
      - директива ассемблера: `section .data`
      - для констант: `section .rodata`
      - если его нет: `section .bss`
  - эта память очищается только в конце работы программы

## `std::string`

Класс для текстовой строки.

Объявлен в заголовочном файле `<string>`.

Работает как массив, но реализует текстовыми операциями.

Как и `std::vector`, не требует `delete[]`.

```c++
std::string s0;  // пустая строка, ""

std::string a(5, 'A');  // "AAAAA"

std::string s5 = "abcdef";   // непустая строка
std::string s5c("abcdef");   // то же самое
std::string s5i{"abcdef"};   // то же самое


using std::literals::operator ""s;
"abcdef"s;  // то же самое

// индексы начинаются с 0!

a[4];      // символ из строки по индексу
a.at(4);   // то же, но с проверкой границ

a[2] = 'z';     // перезапись символа
a.at(2) = 'z';  // то же, но с проверкой границ

a.insert(1, "bbb");       // вставить строку по индексу
a.replace(1, 3, "beef");  // заменить 3 символа с позиции 1
a.substr(1, 4);  // 4 символа из строки, начиная с позиции 1
a.erase(1, 3);   // вырезать 3 символа, начиная с позиции 1

s5.c_str();  // С-style string (указатель `char *`)
s5.data();   // то же, но позволяет изменять данные

s0.length();  // длина строки (кол-во символов)
s0.size();    // то же самое

s0.reserve(10);  // выделить память, чтобы длина строки могла достигнуть 10
s0.capacity();   // кол-во символов, под которые выделенна память

s0.shrink_to_fit();  // очистить неиспользованную память

a.resize(10, 'z');  // увеличить строку, заполнив 'z'
a.append(5, 'z');   // то же самое, но указывается кол-во заполнителей
a.append("lib");    // добавить строку в конец
a.push_back('r');   // то же, но только для одного символа
a += "eoffice";     // то же

// преобразование чисел (только их) к строке
// необходимо для добавления к другой строке
a += std::to_string(25);

a.resize(50);       // увеличить строку, заполнив '\0' (нуль-терминаторами)
a.resize(10);       // обрезать строку

a.find("fAzA");     // найти индекс вхождения строки слева
                    // или спец. значение std::string::npos, если не найдено

// для нескольких вхождений полезно указать начало поиска
size_t i = a.find("Az", 0);  // по умолчанию поиск ведется с начала
i = a.find("Az", i+1);

a.find_first_of("abcdef");  // найти один из перечисленных символов

a.rfind('z');  // то же, но искать с конца
a.rfind('z', std::string::npos);  // то же самое
a.rfind('z', a.length()-1);  // то же самое
a.rfind('z', a.length()-2);   // то же, но с предпоследнего символа

// конкатенация ("склейка"): std::string, char, c_str (т.е. char*)
// использует append
"one"s + ' ' + "apple";

// оператор сравнения c-style строки с std::string
argv[1] == std::string("--help");

// лексикографическое сравнение строк (в т.ч. c-style)
argv[0] < std::string("z++");
"c++"s < "z++"s;

// non-member operator <<
std::cout << a;

// non-member operator >>
// считывает слово (строку непробельных символов),
// перезаписывая объект
std::cin >> a;
```

## `std::format`

В стандарте `C++20` появилась функция `std::format`, работающая очень похоже
на таковую в Python.

Важно: проверка происходит на этапе компиляции

```c++
#include <iostream>
#include <format>

// без указания индексов
std::cout << std::format("{} + {} = {}\n", 2, 2, 5);

// с указанием
std::cout << std::format("{1} + {1} = {0}\n", 3, 2);
std::cout << std::format("{:03.2f}", 42);   // дробное число с минимальной шириной поля 3
```
<!-- std::cout << std::format("{:6}", 'x');  // "x     " -->

После двоеточия можно указать параметры форматирования,
похожие на `printf`-формат:

`{:03.2f}`:
- дробное число
- минимальная ширина поля: 3
- точность: 2 знака после запятой
- заполнение нулями

`{1:03.2f}`: то же самое, но с явным указанием индекса;
второй аргумент, не считая форматной строки

- b - binary (двоичное число)
- c - character (символ)
- d - decimal (десятичное число)
- s - string (строка) (используется, если ничего не указано)
- f - fixed-point (дробное число, без e-нотации)

## Преобразование типов (_type casting_)

Операторы преобразования, добавленные в `C++` (`*_cast`), имеют синтаксис,
похожий на шаблонную функцию.

В отличие от настоящих функций, являются ключевыми словами.

Поэтому не требуют указания пространства имен (`std::`).

### C-style cast (устаревший в C++)

Перебирает разные алгоритмы:
- `const_cast`
- `static_cast`
- `dynamic_cast`
- `reinterpret_cast`
- а также их различные комбинации

<!-- Работает, но лучше использовать  -->

Пример синтаксиса:

```c++
int x = (int) 3.14;  // x = 3;
```

Естественный способ преобразования в `C`,
но в `C++` для предсказуемости лучше никогда его не использовать.

### `static_cast`

Преобразует на этапе компиляции.

```c++
int x = static_cast<int>(3.14);  // x = 3;
```

### `const_cast`

Принудительно убирает или добавляет модификатор `const` к типу.

Обычно не-`const` значения могут быть присвоены к `const`-переменным,
поэтому добавлять `const` не имеет смысла.

Если переменная изначально была `const`, то ее изменение после `const_cast`
вызывает неопределенное поведение.

```c++
int b = 42;
const int *p = &b;
// *p = 32;                   // compile-time error
*const_cast<int *>(p) = 32;   // работает
std::cout << p << std::endl;  // 32
```

```c++
class Counter {
    int i;

    // this имеет тип `const Counter *` из-за модификатора метода `const`
    void meth() const {
        // this->i = 42;  // error
        const_cast<Counter *>(this)->i = 42;  // работает
    }
};
```

Вообще, если его пришлось использовать,
то где-то в архитектуре программы есть серьёзный недочёт...

### `reinterpret_cast`

Преобразует тип, "слепо копируя" двоичное представление значения.

```c++
int x = reinterpret_cast<int>(3.14);  // x теперь не просто 3
// полезно для записи в двоичный файл:
void *data = reinterpret_cast<void *>(some_struct);
```

### `dynamic_cast`

В отличие от других операторов, преобразует во время исполнения (_at runtime_).

Поэтому при ошибке преобразования не прерывает компиляцию, а
- возвращает `nullptr` для указателей
- бросает `std::bad_cast` для ссылок

Для работы требует RTTI (информацию о типах во время исполнения),
которая обычно недоступна.

Но она сохраняется если в классе есть хотя бы один `virtual` метод.

Полезен для динамического полиморфизма.

```c++
Circle c;
Shape *psh;
Circle *pcirc;

psh = &c;  // dynamic_cast не требуется
// pcirc = psh;  // не факт, что фигура - круг
pcirc = dynamic_cast<Circle *>(psh);  // нам поможет dynamic_cast

if(pcirc == nullptr) {
    std::cerr << "Кажется, это был не Circle..." << std::endl;
    std::cerr << "(не может такого быть! я лично его создавал!)" << std::endl;
} else {
    std::cout << pcirc->radius << std::endl;
}
```

## `std::vector`

Класс для динамического массива.

<!-- Это класс, который работает как динамический массив. -->

Объявлен в заголовочном файле `<vector>`.

Деструктор очищает память и вызывает деструкторы элементов: поэтому для
векторов в автоматической памяти (на стеке) не нужно вызывать `delete[]`

Инициализация (конструкторы):

```c++
std::vector<int> v0;             // пустой целочисленный вектор
std::vector<int> v5(5);          // вектор из пяти нулей
std::vector<int> v50(5, 10);     // вектор из пяти десяток
std::vector<int> v15{5, 10};     // вектор из двух элементов: 5 и 10
std::vector<int> v7{7, 15, 35};  // вектор с тремя элементами: 7, 15, 35
// (фигурные скобки создают объект std::initializer_list)

// вектор из пяти объектов (на каждом вызван конструктор без параметров)
std::vector<SomeClass> cs(5);

// динамический набор битов, оптимизированный по памяти
std::vector<bool> bits(32);
```

самые важные методы:

```c++
v50.push_back(10);  // добавить элемент в конец
v50.pop_back();     // удалить элемент в конце

v50[0];          // `operator[]` - получить элемент по индексу
v50[4] = 9;      // он же, но для записи
v50.at(5);       // то же, но с проверкой границ
v50.at(4) = 18;  // перезаписать элемент с проверкой границ

v0.size()       // кол-во хранимых элементов
v0.resize(10);  // задать размер: расширить, заполнив объектами по умолчанию
v7.resize(1);   // задать размер: сократить, вызвав деструкторы
v0.resize(10, 42);  // задать размер: расширить, заполнив 42

v50.capacity()   // кол-во выделенных ячеек памяти
v50.reserve(0)   // ничего не делает
// выделяет память, чтобы могло поместиться суммарно 50 элементов
v50.reserve(50)

v0.data()  // указатель на выделенную память; будет работать как C-style array

v0.insert(v0.begin(); {1, 4, 9, 16});  // вставить элементы в начало

// лексикографическое поэлементное сравение векторов
std::vector{1, 2, 3, 4} < std::vector{1, 2, 4};
```

Пример использования:

```c++
/// Загрузить массив из файла.
/// @param name имя файла
/// @return вектор со значениями из файла
template<typename T>
std::vector<T> load(const std::string &name) {
    std::ifstream f;
    f.open(name);

    std::vector<T> result;

    for(T n; f >> n;) {
        // NOTE: каждый вызов push_back выделяет память наперед.
        result.push_back(n);
    }

    // освободить выделенную но не использованную память
    result.shrink_to_fit();

    // NOTE: нельзя вернуть по ссылке, т.к.
    // она будет указывать на очищенную стековую память
    return result;
}
```

## Обработка исключений

Для обработки исключений используется конструкция `try`/`catch`.

Пример: 

```c++
try {
    double denominator = maybe_zero();
    std::cout << 1.0 / denominator << std::endl;
} catch(std::exception &e) {
    std::cerr << e.what() << std::endl;  // отобразить сообщение об ошибке
    return 1;  // вы
}
```

Исключения это объекты.

Исключение можно вызвать при помощи оператора `throw`:

```c++
if(size < 0)
    // создает _временный_ объект класса invalid_argument
    throw std::invalid_argument("отрицательный размер");
```

## Правило трех и пяти

Правила, специфичные для C++.

<!-- Относится к следующим пяти элементам: -->

Гласит, что если в классе есть хотя бы одно из перечисленного,
следует реализовать и остальное:

1. деструктор
2. конструктор копирования
3. оператор присвоения (_перезаписи_) копированием

Начиная со стандарта `C++11`, к этому списку добавляются еще два элемента:

4. конструктор перемещения
5. оператор присвоения перемещением

(относительно) простой пример реализации: 

```c++
template<typename E>
class Array {
    E *ptr;
    size_t size;

  public:

    // конструктор по умолчанию (без параметров).
    //
    // NOTE: приводит к такому же состоянию, что и "опустошение"
    // объекта при перемещении (см. конструктор и operator= для перемещения)
    Array(): ptr(nullptr), size(0) {}

    // 1) Деструктор.
    // без него: будут удалены стековые переменные ptr и size,
    // НО НЕ ДИНАМИЧЕСКАЯ ПАМЯТЬ ДЛЯ МАССИВА
    ~Array() {
        delete[] ptr;

        // не нужно: будет удалена сама
        // size = 0;
    }

    // 2) Конструктор копирования.
    //
    // без него: будет создаваться т.н. поверхностная копия.
    //
    // в this присвоятся size и ptr,
    // но ptr будет общий с other!
    // это будет не копия объекта, а "ссылка" на него
    // (рабочая, но это не то что мы хотим)
    Array(const Array &other) {
        this->size = other.size;
        this->ptr = new E[size];

        for(size_t i{0}; i < size; i++) {
            ptr[i] = other.ptr[i];
        }

        // NOTE: this и other теперь два независимых объекта

        // можно и так:
        // this->ptr = nullptr;
        // *this = other;
    }

    // 3) Оператор присвоения копированием.
    //
    // без него: то же, что и для конструктора копирования,
    // но к тому же еще и утечка памяти (дин. массив по адресу this->ptr)
    Array &operator =(const Array &other) {
        // в случае "самоприсвоения" даже делать ничего не нужно.
        if(this == &other)
            return *this;

        // происходит перезапись, поэтому освобождаем this.

        // кстати, `delete nullptr` это не ошибка;
        // в этом случае ничего не произойдет
        delete[] this->ptr;

        // выделим память и заполним ее перед присвоением
        // на случай исключения
        E *new_ptr = new E[size];

        for(size_t i{0}; i < size; i++) {
            ptr[i] = other.ptr[i];
        }

        this->ptr = new_ptr;
        this->size = other.size;

        // перегруженные операторы обычно делают так.
        // это для цепных присвоений и для единства с синтаксисом языка.
        return *this;
    }

    // начиная с C++11

    // 4) Конструктор перемещения.
    //
    // без него: пришлось бы лишний раз копировать память из other,
    // несмотря на то что он все равно не нужен.
    Array(Array &&other) {
        // other - либо временный объект,
        // либо явно указанный как условно временный
        // при помощи std::move()

        // "воруем" ресурсы у other, "ему уже все равно" ;)
        ptr = other.ptr;
        size = other.size;

        // Согласно стандарту,
        // теперь other в рабочем, но неуказанном состоянии.

        // в случае с настоящим временным объектом (prvalue),
        // после вызова конструктора перемещения, у пользователя этого класса
        // даже не будет возможности использовать other, т.к. у него даже
        // не было имени.
        // деструктор будет вызван в ближайшее время.

        // в случае с std::move, у пользователя класса остается other.
        // он "рабочий", но "опустошенный".

        // это значит что его можно "восстановить",
        // например вызвав методы инициализации (если такие есть)
        // или присвоив значение, как раз при помощи нашего `operator=`.

        // в обоих случаях, будет вызван деструктор.

        // чтобы он не удалил "украденную" память, укажем,
        // что она больше не принадлежит other,
        // т.е. оставим его в "опустошенном" состоянии
        other.ptr = nullptr;
        other.size = 0;
    }

    // 5) Оператор присвоения перемещением.
    //
    // без него: то же, что и для конструктора перемещения.
    //
    // в случае без конструктора копирования, произошла бы утечка памяти
    // при this->ptr = other.ptr
    Array &operator =(Array &&other) {
        // проверка на "самоприсвоение"
        if(this == &other)
            return *this;

        // перезапись
        delete[] this->ptr;

        ptr = other.ptr;
        size = other.size;

        other.ptr = nullptr;
        other.size = 0;

        return *this;
    }
};
```
