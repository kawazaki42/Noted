$
\alpha = 2.319 \\
a = 2.3 \\
b = 2.4 \\
\\
\delta a = 0.0019 \\
\delta b = 0.0081
$


В узком смысле:

$0.019 \leq 0.05$

$0.081 \leq 0.5$ - только единицы верны


в широком:
$ 0.019 \leq 0.1 $

$ 0.081 \leq 0.1 $ - до десятой включительно верные

6.88754

6.89000

6.89000-6.88754 = 0.00246

> [!CAUTION]
> округляем относительную погрешность только вверх!

Методы Гаусса/Жордана-Гаусса
решения систем линейных алгебраических уравнений (СЛАУ)
===

1\) Метод Гаусса
---

```
{
    a00x0 + a01x1 + ... + a0n-1xn-1 = a0n
    a10x0 + a11x1 + ... + a1n-1xn-1 = a1n
    ...
    am-10x0 + am-11x0 + ... + am-1,n-1xn-1 = am-1,n
}
```

Система размерности (m; n)

m уравнений  
n неизвестных

```
(
    a00    a01    ... a0n-1    | a0n
    a10    a11    ... a1n-1    | a1n
    ...    ...    ... ...      | ...
    am-1,0 am-1,1 ... am-1,n-1 | am-1,n
)
```

### __3 невырожденных преобразования__
1) перемена местами строк;
2) умножение строки на ненулевое число;
3) сложение некоторой строки с другой строкой, умноженной на
   некоторое число

Цель: привести матрицу к ступенчатому виду

```
(
    a00 a01 ... a0k ... a0,n-1 | a0n
    0   a11 ... a1k ... a1,n-1 | a1n
    ...                        | ...
    0   0   ... akk ... ak,n-1 | ak,n
    0   0   0   ...     0      | 0
    ...                        | ...
    0   0   0   ...     0      | 0
)
```

Случаи:
- k = n-1 -> единственное решение
- k < n-1 -> бесконечное множесто решений
- k > n-1 -> для такой картины невозможно

#### Случай, когда нет решений:

```
(
    a00 a01 ... a0k ... a0,n-1 | a0n
    0   a11 ... a1k ... a1,n-1 | a1n
    ...                        | ...
    0   0   ... akk ... ak,n-1 | ak,n
    0   0   0   ...     0      | ak+1,n
    ...                        | ...
    0   0   0   ...     0      | 0
)
```

> Будем рассматривать далее случай, когда $ k = n-1 $,
> т.е. в конце алгоритма квадратная основная матрица.

#### Пример

```
{
    3x1 - 4x2 + x3  = 0
    2x1 + 5x2 - 4x3 = 3
    5x1 - 6x2 + 3x2 = 2
}
```

```
(
    [3] -4  1 | 0 <- ведущая строка
     2   5 -4 | 3
     5  -1  3 | 2
    ^- ведущий столбец
)
```

1) Проверка:

   `akk != 0`

   Выполняется проверкой условия:

   |akk| > epsilon > 0,

   где epsilon - малое число

   Если |akk| <= epsilon, то в строках ниже (i > k)  
   ищем строку, где aik != 0 (|aik| > epsilon) и меняем строки  
   i и k

   (k - номер ведущей строки и столбца)

2) Пересчитываем элементы ниже __и правее__
   ведущей строки и ведущего столбца

       a'ij = (aij * akk - aik * akj) / akk

       (i > k; j > k)

    ```
    (
        3    -4      1    | 0 <- ведущая строка
        2  (23/3) (-14/3) | (3)
        5   (2/3)   (4/3) | (2)
        ^- ведущий столбец
    )
    ```

3) Обнуляем все элементы ведущего столбца __ниже__ ведущего элемента

    ```
    (
         3    -4   1   | 0 <- ведущая строка
        (0) 23/3 -14/3 | 3
        (0)  2/3   4/3 | 2
        ^- ведущий столбец
    )
    ```

    > [!NOTE]
    >
    > На этом этапу выходит примерно то же что и в ручном
    > методе Гаусса

4) Разделим ведущую строку на ведущий элемент, начиная с конца (а то забудем его!)

    ```
    (
        (1)  (-4/3) (1/3) | (0) <- ведущая строка
        0     23/3  -14/3 |  3
        0     2/3     4/3 |  2
        ^- ведущий столбец
    )
    ```

5) Следующая итерация.

    ```
    (
        1    -4/3   1/3   |  0
        0    [23/3] -14/3 |  3 <- ведущая строка
        0     2/3     4/3 |  2
               ^- ведущий столбец
    )
    ```

    ```
    (
        1 -4/3   1/3   |  0
        0   1   -14/23 |  9/23 <- ведущая строка
        0   0    40/23 |  40/23
            ^- ведущий столбец
    )
    ```

    ```
    (
        1 -4/3   1/3   |  0
        0   1   -14/23 |  9/23 <- ведущая строка
        0   0    1     |  1
            ^- ведущий столбец
    )
    ```

    > Прямой ход завершен.
    >
    > Начинается обратный ход

    x[n-1] = a[n-1,n]

    x[2] = 1

    $$x_k = a_{k,n} - \sum\limits_{j-k+1}^{n-1}a_{kj}x_j$$

## 2\) Метод Жордана-Гаусса

Отличие от метода Гаусса: матрицу нужно
привести к диагональному виду

```
(
    1 0 ... 0 | a0n
    0 1 ... 0 | a1n
    ...       |
    0 0 ... 1 | an-1,n
)
```

Тогда $x_n = a_{kn}$

$\forall x \in \{0, 1, ..., n-1\}$

> [!NOTE]
>
> Обратного хода нет!
>
> Только прямой!

#### Пример

```
(
    [3] -4  1 | 0 <- ведущая строка
     2   5 -4 | 3
     5  -1  3 | 2
    ^- ведущий столбец
)
```

> 1-ая итерация

```
(
    1    -4/3   1/3   |  0
    0    [23/3] -14/3 |  3 <- ведущая строка
    0     2/3     4/3 |  2
            ^- ведущий столбец
)
```

2а) пересчитываем элементы правее ведущего столбца и
    не в ведущей строке

```
(
    1    -4/3   -11/23 |  12/23
    0    [23/3] -14/3  |  3     <- ведущая строка
    0     2/3    40/23 |  40/23
            ^- ведущий столбец
)
```

3а) Обнуляем в ведущем столбце все элементы, кроме ведущего

```
(
    1      0    -11/23 |  12/23
    0    [23/3] -14/3  |  3     <- ведущая строка
    0      0     40/23 |  40/23
            ^- ведущий столбец
)
```

4а) = 4)

```
(
    1      0    -11/23  |  12/23
    0      1    -14/23  |   9/23
    0      0    [40/23] |  40/23     <- ведущая строка
                   ^- ведущий столбец
)
```

```
(
    1      0       0  |  1
    0      1       0  |  1
    0      0       1  |  1     <- ведущая строка
                   ^- ведущий столбец
)
```

> Ответ: $(1; 1; 1)$

Метод LU-разложения СЛАУ (Холецкого)
===

Теорема: любую невырожденную квадратную матрицу
можно представить в виде произведения нижнетреугольной
и верхнетреугольной

Система уравнений AX = B

согласно теореме: A = LU

LUX = B

пусть UX = Y

LY = B  // система приведенная к треугольному виду.

обратный ход даст вектор Y

UX = Y  // тоже система приведенная к треугольному виду.

обратный ход даст нам вектор X

### шаг 1

```pseudocode
A = (
    a00 a01 a02 a03
    a10 a11 a12 a13
    a20 a21 a22 a23
    a30 a31 a32 a33
) = (
    l00 0   0   0
    l10 l11 0   0
    l20 l21 l22 0
    l30 l31 l32 l33
) * (
    u00 u01 u02 u03
    0   u11 u12 u13
    0   0   u22 u23
    0   0   0   u33
) = (
    l00u00 l00u01          l00u02
    l10u00 l10u01 + l11u11 l10u02
    l20u00 l20u01 + l21u11
    l30u00 l30u01 + l31u11
)
```

a00 = l00u00

элементы главной диагонали L или U мы ставим в единицы

Замечание:

все u_{kk} = 1

```
l00 = a00
l10 = a10
l_{n-1,0} = a1_{n-1,0}
```

#### 0 слой:

$$l_{i0} = a_{i0} \ (i = 0, ..., n-1)$$

$$u_{0j} = a_{0j} / l_{00} \ (j = 0, ..., n-1)$$

#### 1 слой:

$$l_{i0}u_{01} + l_{i1} \cdot 1 = a_{i1}$$

$$l_{i1} = a_{i1} - l_{i0}u_{01}$$

l_{10}u_{0j} + l_{11}u{1j} = a_{1j}

u_{1j}

(j=2, ..., n-1)

#### 2 слой:

$$l_{i2} = a_{i2} - l_{i0} u{02} - l_{i2} u_{12} (i = 2, ..., n-1)$$

$$u_{2j} = \frac{a_{2j} - l_{20} u_{0j} - l_{22} u_{2j}} {l_{22}} (j = 3, ..., n-1)$$

Обобщение:
#### k слой

> ```math
> l_{ik} = a_{ik} - \sum \limits_{m=0} ^{k-1} l_{im} u_{mk}
> \\
> (k = 1, ..., n-1)
> \\
> (i = 1, ..., k)
> ```

> ```math
> u_{kj} = \frac {a_{kj} - \sum \limits_{m=0} ^{k-1} l_{km} u_{mj}} {l_{kk}}
> \\
> (k = k+1, ..., n-1)
> ```

### шаг 2

LY = B = A_n

y_0 = a_{0n} / l_{00}

y_1 = \frac{a_1n - l_{10} y_0} {l_{11}}

```math
y_k = \frac{a_{kn} - \sum \limits _{m=0} ^{k-1} l_{km} y_m} {l_{kk}}
\\
(k = 1, ..., n-1)
```

### шаг 3

UX = Y

x_{n-1} = y_{n-1}

> ```math
> x_k = y_k - \sum \limits _{m=k+1} ^{n-1} u_{km}x_m
> \\
> (k = n-2, ..., 0)
> ```
> 
> уменьшение индекса!

Ctrl+Shift+Enter