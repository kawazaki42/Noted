```asm
mov eax, 0x04  ; в eax записать число
```

```pascal
{$asmmode intel}

var
  a: Byte;

begin
  asm
    mov AL, 42
    mov a, AL
  end;
end.
```

<!-- EAX [                [   AH   |   AL   ]]] -->

EAX - 32 бит
AX - 16 бит
AL, AH - по 8 бит

то же самое для:   
EBX, BX, BH, BL  
ECX, CX, CH, CL
EDX, DX, DH, DL

ESI, EDI, EBP, ESP  
 SI,  DI,  BP,  SP

```
mov AL, 17
mov AX, 300  ; перезапишет! т.к. AX = AH + AL
mov BX, 300  ; норм
```

```asm
add r1, r2

; AL=2
add AL, 3
; AL=5
```

```asm
// присвоение

MOV AL, BL  // или число

// сложение

ADD AL, BL  // или число; храним результат в AL

// вычитание

SUB AL, BL  // или число; храним результат в AL

// умножение

MOV AL, 3
MUL AL, 5  // или регистр; храним результат в AX (чтобы влезло!)

MOV AX, 3
MUL AX, 5  // или регистр; храним в DX:AX (мда уж, почему не EAX)

MOV EAX, 3
MUL EAX, 5  // или регистр; храним в EDX:EAX

// деление

MOV AX, 31
MOV BL, 5
DIV BL  // можно было сразу 5
// Делимое обязательно в AX, EAX
// Результат в AL (в нашем случае 6)
// Остаток в AH (1)

MOV DX:AX, 31
DIV 5
// Результат в AX
// Остаток в DX
```

Если надо работать со знаками, то IMUL и IDIV

INC, DEC - увеличить/уменьшить на 1

> ### Задача
>
> 3 числа, домножим их на порядковый номер
> 
> то есть 1ое умножим на 1, 2ое на 2, 3е на 3 (используя INC)
> 
> Складываем их
> 
> Сумму делим на 3
> 
> Из результата вычитаем остаток деления умноженный на 3
> 
> И выводим то что получилось

```asm
mov AL, 12
mov BL, 31
mov CL, 5

mov AH, 1
mul AL, AH
inc AH
```

AX (16 бит): AH (верхние 8 бит), AL (нижние 8 бит)

Не забываем что EAX, AX, AH, AL связаны;
стараемся их не смешивать

```pseudocode
IF(condition) {} else {}

{
  F1: cond ? data1 : data2
}
```

метки

```asm
  // asm code
  // . -> goto label2
  // asm code
label1:
  // asm code
label2:
  // ...
label3:
  // ...
```

при исполнении метки сами по себе игнорируются.

```asm
cmp R, R/V
// ставит флаги

jmp label2  // безусловный переход
```

J - jump (переход)

N - not (не; отрицание)

Z - zero (ноль)

E - equal (равно)

G - greater (больше)

L - less (меньше)

```asm
CMP A, B
JE label2  // перейти на label2 если a = b
```

JG - если больше

JGE - больше или равно

JL - меньше

JLE - меньше или равно

JNE - если НЕ равно

JZ - если равно нулю


GOTO: похоже на быстрые переходы между локациями в играх

> ДЗ: проверить четность числа

> доп: проверить кратность

---

фции обычно пишутся в конце

```
    call sum  // пишет адрес текущей инструкции в стек ("стопку")
// ...
sum:
    push ax  // запихивает в стек какие то данные
    mov ax, 1
    mov bx, 2
    add ax, bx
    ret  // вытаскивает оттуда адрес и переходит по нему
```

```
    push ax
    push bx
    push cx
    call f1
    // на стеке: ax, bx, cx, адрес возврата <- вершина стека
// ...
sum:
    pop dx  // адрес возврата ушел в dx
    pop r1  // cx в r1
    pop r2  // bx в r2
    pop r3  // ax в r3

    push dx  // возвращаем адрес возврата в стек
    ret
```

> ДЗ:
>
> цикл который вызывает функцию которая работает как инструкция `add`
>
> аргументы через стек!

<!-- > цикл который выполняется 10 раз внутри которого выполняются функция
> с 2 аргументами: начальное число и какое то другое число
> она должна к исходному -->
<!-- > написать функцию которая в цикле будет умножать число на 2 и вычитать 1
> также 10 раз (а точнее передать ей ) -->