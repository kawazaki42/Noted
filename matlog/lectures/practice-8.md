# Машина Тьюринга

1
---

A = {0;1}

Q = {q_1, q_2, q_0}

$q_0 \in Q$

q_1 0 -> q_1 0 R

q_1 1 -> q_2 0 R

q_2 0 -> q_0 1 S

q_2 1 -> q_1 0 R

во что преобразуются

- a) P_1 = 0 1 1 1 0 1 0

```
    q_1
0   1   1   1   0   1   0
```

мы условимся что с 1 ненулевого

```
        q_2
0   0   1   1   0   1   0
```

```
            q_1
0   0   0   1   0   1   0
```

```
                q_2
0   0   0   0   0   1   0
```

```
                q_0
0   0   0   0   1   1   0
```

> $P_1 ' = 0 0 0 0 1 1 0$

- б) P_2 = 0 1 1 1 1 0

```
    q_1
0   1   1   1   1   0
```

```
        q_2
0   0   1   1   1   0
```

```
            q_1
0   0   0   1   1   0
```

```
                q_2
0   0   0   0   1   0
```

```
                    q_1
0   0   0   0   0   0
```

данная машина тьюринга неприменима к данному слову

потомучто ушли в цикл

## Задание 2

построить МТ, которая имея на ленте два массива из единиц разделенных
нулями заполняет эти нули единицами и останавливается у последней единицы
второго массива

начало:

```
    q_1
0   1   1   1   0   0   0   1   1   1   1   0
```

```
                                        q_0
0   1   1   1   1   1   1   1   1   1   1   0
```

1) пройти первый массив единиц
2) найти массив нулей
3) заменить 1ый найденный ноль единицей

1 шаг

q_1 1 -> q_1 1 R

q_1 0 -> q_2 1 R

2 шаг

идти через массив нулей, заменяя 1, пока не появится 2 массив единиц

q_2 0 -> q_2 1 R

q_2 1 -> q_3 1 R

3 шаг

пройти 2 массив единиц и остановиться в конце

q_3 1 -> q_3 1 R

q_3 0 -> q_0 0 L

это ок то что нету S

# Универсальная кодировка МТ

для нее занумеруем входной алфавит,
множество состояний
и действий натуральными числами, начиная с 0

D = {R, L, S}

A, Q


| R   | L   | S   | a_0 | a_1 | ... | a_k  | q_0 | q_1 | ... | q_n |
| --- | --- | --- | --- | --- | --- | ---- | --- | --- | --- | --- |
| 1   | 3   | 5   | 7   | 9   |     | 2k+1 | 0   | 2   |     | 2n  |

тогда любую команду можно закодировать набором из 5 чисел

этот набор представить {1; *}

стандартным образом, вместо разделяющих нулей - *

получаем код команды, который можно обозначить через букву k

код всей программы

K(M) = K_1 * K_2 * ... * K_p

K_i - универсальный код каждой команды

## Пример (3)

- q_1 1 -> q_1 1 R
- q_1 0 -> q_2 1 L
- q_2 1 -> q_2 1 L
- q_2 0 -> q_0 0 R

---

- 2 * 9 * 2 * 9 * 1
- 2 * 7 * 4 * 9 * 3
- 4 * 9 * 4 * 9 * 3
- 4 * 7 * 0 * 7 * 1

0 -> 1
1 -> 2
2 -> 3
...

- K_1 = 1^3 * 1^10 * 1^3 * 1^10 * 1^2
- K_2 = 1^3 * 1^8 * 1^5 * 1^10 * 1^4
- K_3 = 1^5 * 1^10 * 1^5 * 1^10 * 1^4
- K_4 = 1^5 * 1^8 * 1 * 18 * 1^2

вот эта запись очень важная за нее баллы могут снизить

K(M) = K_1 * K_2 * K_3 * K_4

## Пример (4)

A = {a_0; 1}

Q = {q_0; q_1}

q_1 a_0 -> q_0 1 S

(S можно не писать)

q_1 1 -> q_1 1 П

```
              q_1
1   a_0   1   1   a_0   a_0   1   1
```

```
                  q_1
1   a_0   1   1   a_0   a_0   1   1
```

```
                  q_0
1   a_0   1   1   1     a_0   1   1
```

---

```

```

> Егошин - в примерах и задачах

все задачи из книги взяты!

> КР №4 13 дек 2025 в 18:00
>
> конец - 20:00
